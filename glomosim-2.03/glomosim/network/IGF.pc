#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include "api.h"
#include "structmsg.h"
#include "fileio.h" 
#include "message.h"
#include "network.h"
#include "IGF.h"
#include "ip.h"
#include "udp.h"
#include "nwip.h"
#include "nwcommon.h"
#include "application.h"
#include "transport.h"
#include "java_gui.h"

#define ABSOLUTE_VALUE(x) (x)>=0 ? (x):(0-(x))  
#define IGF_DELAYBEFOREBEACON (20*SECOND)
#define	MAX_BEACON_LIMIT	 3

IGF_LOCATION_SERVICE_TABLE IGF_global_ls_table;

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFInit(GlomoNode *node, 
		   GlomoRoutingIGF **IGFPtr, 
		   const GlomoNodeInput *nodeInput){
  
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  char buf[GLOMO_MAX_STRING_LENGTH];
  char beaconIntervalStr[GLOMO_MAX_STRING_LENGTH];
  BOOL retVal;
  clocktype beacon_interval;
  GlomoRoutingIGF *IGF = checked_pc_malloc(sizeof(GlomoRoutingIGF));
	
  NetworkIpSetRouterFunction(node, &RoutingIGFRouterFunction);
	
  //schedule beacon

  retVal = GLOMO_ReadString(node->nodeAddr, nodeInput, 
			    "IGF_BEACON_INTERVAL", buf);
  if(retVal == FALSE){
    fprintf(stderr, "No IGF_BEACON_INTERVAL in IGF.in\n");
    assert(FALSE);
    abort();	
  }
  beacon_interval = GLOMO_ConvertToClock(buf);
  GLOMO_PrintClockInSecond(beacon_interval, beaconIntervalStr);

  IGF->numBeacons = 0;

  IGF->beacon_interval = beacon_interval;
  *IGFPtr = IGF;
	
  if(node->nodeAddr == 0) {
    IGF_LocServ_Init();
  }
	
  IGF_LocServ_AddEntry(node);
  IGF_InitStats(node);
  IGF_InitNT(&IGF->nt);

  IGF_Enable_ScheduleABeacon(node);

}

//***************************************************************************
//***************************************************************************
//***************************************************************************
// delay the time to start the first beacon schedule
void IGF_Enable_ScheduleABeacon(GlomoNode *node){
  Message *enableScheduleABeaconTimer;
  clocktype delay;	
	
  //enableScheduleABeaconTimer is used to start the first beacon schedule
  enableScheduleABeaconTimer = GLOMO_MsgAlloc(node,GLOMO_NETWORK_LAYER,
					      ROUTING_PROTOCOL_IGF,
					      MSG_NETWORK_EVENT_IGFEnableScheduleABeacon);
  delay= IGF_DELAYBEFOREBEACON;
  GLOMO_MsgSend(node, enableScheduleABeaconTimer, delay);
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_InitStats(GlomoNode * node){
  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
	
  IGF->stats.numOfBeaconPkts = 0;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_ScheduleABeacon(GlomoNode *node) {

  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
  Message * scheduleABeaconTimer;
  Message * startABeaconTimer;
  NODE_ADDR * info;
  clocktype delay;
  double randomNumber;
  char buf[GLOMO_MAX_STRING_LENGTH];
  char TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
	
	
  //scheduleABeacon is used to set periodic beacon
  scheduleABeaconTimer = GLOMO_MsgAlloc(node, GLOMO_NETWORK_LAYER,
					ROUTING_PROTOCOL_IGF,
					MSG_NETWORK_EVENT_IGFScheduleABeacon);
  GLOMO_MsgInfoAlloc(node, scheduleABeaconTimer,sizeof(NODE_ADDR));
  info = (NODE_ADDR *) GLOMO_MsgReturnInfo(scheduleABeaconTimer);
  *info= node->nodeAddr;
  delay= IGF->beacon_interval;
  GLOMO_MsgSend(node, scheduleABeaconTimer, delay);	
	
  //startABeaconTimer is used to send a beacon
  startABeaconTimer = GLOMO_MsgAlloc(node, GLOMO_NETWORK_LAYER,
				     ROUTING_PROTOCOL_IGF,
				     MSG_NETWORK_EVENT_IGFStartABeacon);
  GLOMO_MsgInfoAlloc(node, startABeaconTimer, sizeof(NODE_ADDR));
  info = (NODE_ADDR *)GLOMO_MsgReturnInfo(startABeaconTimer);
  *info= node->nodeAddr;
  randomNumber = pc_erand(node->seed);
  delay = randomNumber*IGF->beacon_interval;
  IGF->stats.numOfBeaconPkts ++;
  GLOMO_MsgSend(node, startABeaconTimer,delay);
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFFinalize(GlomoNode *node){
  char buf[GLOMO_MAX_STRING_LENGTH];
  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol; 

  sprintf(buf, "Number of CTRL Packets Txed = %d", 
	  IGF->stats.numOfBeaconPkts );
  GLOMO_PrintStat(node, "RoutingIGF", buf);
	
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFHandleProtocolPacket(GlomoNode *node, Message *msg, 
				   NODE_ADDR srcAddr, 
				   NODE_ADDR destAddr){
	
  IGF_PACKET_TYPE * packetType = (IGF_PACKET_TYPE *)GLOMO_MsgReturnPacket(msg);
	
  switch(*packetType){
  case IGF_PACKET_TYPE_BEACON:{
    IGF_HandleABeaconPacket(node,msg);
    break;
  }
		
  default:{
    assert(FALSE);
    abort();
  }
  }
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_HandleABeaconPacket(GlomoNode * node, Message* msg){
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *) node->networkData.networkVar;
  GlomoRoutingIGF *IGF = (GlomoRoutingIGF *) ipLayer->routingProtocol;
  IGF_BEACON_PACKET *beaconPacket = (IGF_BEACON_PACKET *) GLOMO_MsgReturnPacket(msg);
  char TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  IGF_NT *nt=&(IGF->nt);
  IGF_NT_ENTRY * currEntry, *newEntry;
  BOOL FOUND = FALSE;
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);

  // If the neighbor is not in the NT, add it
  // .....
  //
  for(currEntry=nt->head;currEntry!=NULL;currEntry=currEntry->next){
      if(currEntry->neighborID==beaconPacket->nodeID){
          FOUND = TRUE;
          break;
      }
  }

  if(!FOUND){
      newEntry = checked_pc_malloc(sizeof(IGF_NT_ENTRY));
      newEntry->neighborID = beaconPacket->nodeID;
      newEntry->neighborPosition = beaconPacket->nodePosition;
      newEntry->refreshStatus = TRUE;
      newEntry->neighborStatus = TRUE;
#ifdef IGF_DEBUG
      //if(node->nodeAddr==0)
      //    IGF_PrintNT(node,&nt);
      //printf("[SIM: %15s] IGF--Node %d being added to node %d's neighbor list \n",TimeStringInSecond,
      //   beaconPacket->nodeID,node->nodeAddr);
#endif
      IGF_AddAEntryIntoNT(nt,newEntry);
  }
  GLOMO_MsgFree(node,msg);
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
//before add the new entry into it, we assume that it is not in the NT
void IGF_AddAEntryIntoNT(IGF_NT *nt, IGF_NT_ENTRY *newEntry) {
  IGF_NT_ENTRY * currEntry;
  IGF_NT_ENTRY * rear;
  char 	TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);
	
  if(nt->head == NULL){
    nt->head 	= newEntry;
    newEntry->next	= NULL;
    nt->size ++;
#ifdef IGF_DEBUG
      //if(node->nodeAddr==0)
      //    IGF_PrintNT(node,&nt);
    //printf("[SIM: %15s] IGF--Node %d added to neighbor list \n",TimeStringInSecond,
    //       newEntry->neighborID);
#endif
    return;
  }
	
  for(currEntry = nt->head; currEntry != NULL; currEntry = currEntry->next){
    rear = currEntry;
  }
  rear->next = newEntry;
  newEntry->next = NULL;
  nt->size++;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_InitNT(IGF_NT * nt){
  nt->head = NULL;
  nt->size = 0;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFHandleProtocolEvent(GlomoNode *node, Message *msg){
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF *IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;

  switch(msg->eventType){
  case MSG_NETWORK_EVENT_IGFScheduleABeacon:{
    IGF_ScheduleABeacon(node);
    GLOMO_MsgFree(node, msg);
    break;
  }
  case MSG_NETWORK_EVENT_IGFStartABeacon:{
    IGF_SendABeacon(node);
    GLOMO_MsgFree(node,msg);
    break;
  }
  case MSG_NETWORK_EVENT_IGFEnableScheduleABeacon:{
    // Legacy MSG. Although identical with IGFScheduleABeacon right now,
    // it was designed for a different purpose (i.e., there were a few other
    // things done when this message was received.
    IGF_ScheduleABeacon(node);
    GLOMO_MsgFree(node, msg);
    break;	
  }
  default:{
    assert(FALSE);
    abort();
  }
  }
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_SendABeacon(GlomoNode * node) {

  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
  Message * newMsg = GLOMO_MsgAlloc(node, 0,0,0);
  IGF_BEACON_PACKET * beaconPacket;
  char TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  int pktSize = sizeof(IGF_BEACON_PACKET);

  GLOMO_MsgPacketAlloc(node, newMsg, pktSize);
  //beaconPacket = checked_pc_malloc(sizeof(IGF_BEACON_PACKET));
  beaconPacket =  (IGF_BEACON_PACKET *) GLOMO_MsgReturnPacket(newMsg);

  beaconPacket->packetType = IGF_PACKET_TYPE_BEACON;
  beaconPacket->nodeID = node->nodeAddr;
  beaconPacket->nodePosition = node->position;
  
  // send a beacon through NetworkIpSendRawGlomoMessage
  // ....
  //
  NetworkIpSendRawGlomoMessage(
     node, newMsg, ANY_DEST, CONTROL, IPPROTO_IGF, 1);

}


//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFRouterFunction(GlomoNode *node,
			     Message *msg,
			     NODE_ADDR destAddr,
			     BOOL *packetWasRouted){
	
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF *IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
  IpHeaderType *ipHeader = (IpHeaderType *) msg->packet;
	
  if(ipHeader->ip_p ==  IPPROTO_IGF){
    // this is the control packet, ignore it
    return;
  }
  if(ipHeader->ip_src == node->nodeAddr)
    {
      *packetWasRouted = TRUE;
    }
  if(node->nodeAddr == destAddr){
    *packetWasRouted = FALSE;
  }else{
    *packetWasRouted = TRUE;
  }
	
  IGF_MakeRoutingDecision(node, msg, destAddr);
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_PrintNT(GlomoNode * node, IGF_NT * nt) {

  IGF_NT_ENTRY *currEntry;
	
  printf("\nThe neighbor table of node %d is:\n", node->nodeAddr);
  for(currEntry = nt->head; currEntry != NULL; currEntry = currEntry->next){
    printf("neighborID: %d \t neighborPosition: (%f,%f,%f) \t ",
	   "neighborStatus: %d \t refreshStatus: %d\n", 
	   currEntry->neighborID, 
	   currEntry->neighborPosition.x, 
	   currEntry->neighborPosition.y, 
	   currEntry->neighborPosition.z,
	   currEntry->neighborStatus,
	   currEntry->refreshStatus);
  }

  printf("\n");

}


//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_MakeRoutingDecision(GlomoNode *node, 
			    Message * msg, 
			    NODE_ADDR destAddr) {

  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
  IpHeaderType * ipHeader = (IpHeaderType *) msg->packet;
  IGF_NT *nt = &(IGF->nt);
  NODE_ADDR nextHop;
  char 	TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);

  if(ipHeader->ip_src == node->nodeAddr) {

#if MYDEBUG
    printf("IGF--Node %d sends out a packet to node %d\n",
	   node->nodeAddr,destAddr);
#endif
    
  }

  if(node->nodeAddr == destAddr) {

#if MYDEBUG
    printf("IGF--Node %d receives a packet from %d\n",
	   node->nodeAddr,ipHeader->ip_src);
#endif

    return; 
  } else {

    // Get the next hop and send the packet to the MAC layer
    // through NetworkIpSendPacketToMacLayer
    // ....
      // TODO
      nextHop = IGF_GetNextHop(nt,node,destAddr);
      if(nextHop != 0xffff){
    
          NetworkIpSendPacketToMacLayer(node, msg, DEFAULT_INTERFACE, nextHop);
      }else{
          #ifdef IGF_DEBUG
          printf("[SIM: %15s] IGF--Node %d could not send out a packet to node %d via neighbor %d no closer nbr found \n",
                 TimeStringInSecond,node->nodeAddr,destAddr,nextHop);
#endif
      }
  }
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
NODE_ADDR IGF_GetNextHop(IGF_NT *nt, GlomoNode * node, NODE_ADDR destAddr) {

  IGF_NT_ENTRY *curr_nt_entry;
  NODE_ADDR nextHop = 0xffff;
  GlomoCoordinates destPosition = IGF_LocServ_Lookup(destAddr);
  double minDistance = IGF_GetDistance(node->position, destPosition);
  double currDistance;
  char TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  GlomoCoordinates nextHopPosition = node->position;
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);

  // Get the next hop, closer to the destination than me
  // ...
  //
#ifdef IGF_DEBUG
  //printf("[SIM: %15s] IGF--Node %d finding nbr nearest to %d \n",TimeStringInSecond,
  //               node->nodeAddr,destAddr);
#endif
  for(curr_nt_entry=nt->head;curr_nt_entry!=NULL;curr_nt_entry=curr_nt_entry->next){
      currDistance = IGF_GetDistance(curr_nt_entry->neighborPosition,destPosition);
#ifdef IGF_DEBUG
      //printf("[SIM: %15s] IGF--Node %d <-> %d : %f|%d <-> %d : %f \n",TimeStringInSecond,
      //           node->nodeAddr,curr_nt_entry->neighborID,currDistance,
      //           node->nodeAddr,nextHop,minDistance);
#endif
      if(currDistance < minDistance){
          minDistance = currDistance;
          nextHop = curr_nt_entry->neighborID;
          nextHopPosition = curr_nt_entry->neighborPosition;
      }
  }
#ifdef IGF_DEBUG
          printf("[SIM: %15s] IGF--Node %d sends out a packet to node %d via neighbor %d(%f,%f,%f) \n",
                 TimeStringInSecond,node->nodeAddr,destAddr,nextHop,nextHopPosition.x,
                 nextHopPosition.y,nextHopPosition.z);
#endif
  return nextHop;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
double IGF_GetDistance(GlomoCoordinates sourceAddr, GlomoCoordinates destAddr){
  double distance_x = ABSOLUTE_VALUE(sourceAddr.x - destAddr.x);
  double distance_y = ABSOLUTE_VALUE(sourceAddr.y - destAddr.y);
  double distance_z = ABSOLUTE_VALUE(sourceAddr.z - destAddr.z);
	 
  return sqrt(distance_x*distance_x + distance_y*distance_y + 
	      distance_z*distance_z);
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_LocServ_Init() {
  IGF_global_ls_table.head = NULL;
  IGF_global_ls_table.size = 0;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_LocServ_AddEntry(GlomoNode *node) {
  IGF_LOCATION_SERVICE_ENTRY *currEntry;
  IGF_LOCATION_SERVICE_ENTRY *rearEntry;
  IGF_LOCATION_SERVICE_ENTRY *newEntry = (IGF_LOCATION_SERVICE_ENTRY *) 
      checked_pc_malloc(sizeof(IGF_LOCATION_SERVICE_ENTRY));
  char 	TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);

  newEntry->nodeAddr = node->nodeAddr;
  newEntry->position = node->position;

  // Add the newEntry to the IGF_global_ls_table
  // ...
  //
  newEntry->next = IGF_global_ls_table.head;
  IGF_global_ls_table.head = newEntry;
  IGF_global_ls_table.size++;
  #ifdef IGF_DEBUG
  //printf("[SIM: %15s] %d Added in the LS service\n",TimeStringInSecond,node->nodeAddr);
  #endif
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
GlomoCoordinates IGF_LocServ_Lookup(NODE_ADDR nodeAddr){
  IGF_LOCATION_SERVICE_ENTRY * 	currEntry;
  GlomoCoordinates		result_position;
  BOOL							wasFound;
	
  wasFound = FALSE;

  // Loop over all entries in IGF_LOCATION_SERVICE and return the location of node
  // .....
  // .....
  // TODO
  for(currEntry = IGF_global_ls_table.head;currEntry!=NULL;currEntry=currEntry->next){
      if(currEntry->nodeAddr==nodeAddr){
          wasFound = TRUE;
          result_position = currEntry->position;
          break;
      }
  }

  if(!wasFound){
    printf("Fail to find the location of node %d\n",nodeAddr);
    abort();
  }
  return result_position;
}

void IGF_updateLocation(NODE_ADDR nodeAddr, GlomoCoordinates position){
    BOOL wasFound = FALSE;
    IGF_LOCATION_SERVICE_ENTRY * currEntry;
    for(currEntry = IGF_global_ls_table.head;currEntry!=NULL;currEntry=currEntry->next){
        if(currEntry->nodeAddr==nodeAddr){
            wasFound = TRUE;
            currEntry->position=position;
            break;
        }
    }

}
