
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include "api.h"
#include "structmsg.h"
#include "fileio.h" 
#include "message.h"
#include "network.h"
#include "IGF.h"
#include "ip.h"
#include "udp.h"
#include "nwip.h"
#include "nwcommon.h"
#include "application.h"
#include "transport.h"
#include "java_gui.h"

#define ABSOLUTE_VALUE(x) (x)>=0 ? (x):(0-(x))  
#define IGF_DELAYBEFOREBEACON (20*SECOND)
#define	MAX_BEACON_LIMIT	 3

IGF_LOCATION_SERVICE_TABLE IGF_global_ls_table;

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFInit(GlomoNode *node, 
		   GlomoRoutingIGF **IGFPtr, 
		   const GlomoNodeInput *nodeInput){
  
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  char buf[GLOMO_MAX_STRING_LENGTH];
  char beaconIntervalStr[GLOMO_MAX_STRING_LENGTH];
  BOOL retVal;
  clocktype beacon_interval;
  GlomoRoutingIGF *IGF = checked_pc_malloc(sizeof(GlomoRoutingIGF));
	
  NetworkIpSetRouterFunction(node, &RoutingIGFRouterFunction);
	
    *IGFPtr = IGF;
	
  if(node->nodeAddr == 0) {
    IGF_LocServ_Init();
  }
	
  IGF_LocServ_AddEntry(node);
  IGF_InitStats(node);
  
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_InitStats(GlomoNode * node){
  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
	
  IGF->stats.numOfBeaconPkts = 0;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFFinalize(GlomoNode *node){
  char buf[GLOMO_MAX_STRING_LENGTH];
  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol; 

  sprintf(buf, "Number of CTRL Packets Txed = %d", 
	  IGF->stats.numOfBeaconPkts );
  GLOMO_PrintStat(node, "RoutingIGF", buf);
	
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFHandleProtocolPacket(GlomoNode *node, Message *msg, 
				   NODE_ADDR srcAddr, 
				   NODE_ADDR destAddr){
	
    assert(FALSE);
    abort();
}

//anku
void IGF_UpdateRoutingTable(GlomoNode * node, NODE_ADDR destaddr, NODE_ADDR nextHop){
    BOOL found = FALSE;
    GlomoNetworkIp *ipLayer = (GlomoNetworkIp *) node->networkData.networkVar;
    GlomoRoutingIGF *IGF = (GlomoRoutingIGF *) ipLayer->routingProtocol;
    IGF_RT *rt = &(IGF->routeTable);
    IGF_RT_Node *currEntry,*newEntry;
    for(currEntry=rt->head;currEntry!=NULL;currEntry=currEntry->next){
        if(currEntry->destAddr==destaddr){
            currEntry->nextHop = nextHop;
            found = TRUE;
     }

 }
    if(found==FALSE){
        newEntry = checked_pc_malloc(sizeof(IGF_RT_Node)); 
        newEntry->destAddr = destaddr;
        newEntry->nextHop = nextHop;
        IGF_AddEntryIntoRT(rt,newEntry);
    }

}

//Method to add entry in routing table
void IGF_AddEntryIntoRT(IGF_RT *rt,IGF_RT_Node *newrtEntry){
    IGF_RT_Node * currEntry;
    IGF_RT_Node * rear;
    if(rt->head == NULL){
        rt->head = newrtEntry;
        newrtEntry->next = NULL;
        rt->size ++;
        return;
    }
    for(currEntry = rt->head;currEntry != NULL;currEntry = currEntry->next){
        rear = currEntry;
     }
    rear->next = newrtEntry;
    newrtEntry->next = NULL;
    rt->size++;


}

//anku
void IGF_InitRT(IGF_RT * rt){
    rt->head = NULL;
    rt->size = 0;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFHandleProtocolEvent(GlomoNode *node, Message *msg){
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF *IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;

  switch(msg->eventType){
  default:{
    assert(FALSE);
    abort();
  }
  }
}


NODE_ADDR ConvertRawAddressBytesToNodeAddress(char RawAddressBytes[]) {

   // Done because the address bytes may be out of alignment
   // on certain processors.
   
   NODE_ADDR nodeAddress;
   memcpy(&nodeAddress, RawAddressBytes, sizeof(NODE_ADDR));
   return nodeAddress;
}

void SetRawAddressBytes(NODE_ADDR nodeAddress, char RawAddressBytes[]) 
{
   // Done because the address bytes may be out of alignment
   // on certain processors.
   
   memcpy(RawAddressBytes, &nodeAddress, sizeof(NODE_ADDR));
}


void IGF_AddToRouteRecord(GlomoNode *node, Message *msg)
{
    IpHeaderType *ipHeader = (IpHeaderType *) msg->packet;
    char* NewRoutePositionPtr;
   /* Reuse unused IP Option "ptr" field.
      (minimizes overhead to 4 bytes).
   */
   IpOptionsHeaderType* ipOption = FindAnIpOptionField(ipHeader, IPOPT_RR);
    
   if (ipOption == NULL) {
      IpOptionsHeaderType* forSizeof;
      AddIpOptionField(node, msg, IPOPT_RR,0);
      ipOption = FindAnIpOptionField((IpHeaderType *) msg->packet, IPOPT_RR);
   }
   if(ipOption->len<60){
       ExpandOrShrinkIpOptionField(node, msg, IPOPT_RR,((ipOption->len) + sizeof(NODE_ADDR)) );
   //DisplayRouteOfPacket(node,msg);
       ipOption = FindAnIpOptionField((IpHeaderType *) msg->packet, IPOPT_RR);
       NewRoutePositionPtr = (char *)ipOption + ipOption->len - sizeof(NODE_ADDR);
       SetRawAddressBytes(node->nodeAddr,NewRoutePositionPtr);
   }else{
       if(ipOption->ptr>=ipOption->len){
           ipOption->ptr = IPOPT_MINOFF;
       }
       NewRoutePositionPtr = (char *)ipOption + ipOption->ptr;
       SetRawAddressBytes(node->nodeAddr,NewRoutePositionPtr);
       ipOption->ptr+=sizeof(NODE_ADDR);
   }
   //DisplayRouteOfPacket(node,msg);
}

void DisplayRouteOfPacket(GlomoNode *node, Message *msg) 
{
    IpOptionsHeaderType* ipOptions = 
        FindAnIpOptionField((IpHeaderType*)msg->packet,IPOPT_RR);
    
    char temp = ipOptions->ptr;
    while (temp < ipOptions->len) {
        
        // Extract Next Address 
        // The definition of "ptr" seems to number 1 as the 
        // first byte of the the options field.
        
        char* routeRawAddressBytes = (char*)ipOptions + temp;
        
        NODE_ADDR nextHop = 
            ConvertRawAddressBytesToNodeAddress(routeRawAddressBytes);
        
        // Record Route (Replace next address with this node's address).
        
        temp += sizeof(NODE_ADDR);
        
        printf(" %d -> ",nextHop);
    } 
    printf("\n");
}       


//***************************************************************************
//***************************************************************************
//***************************************************************************
void RoutingIGFRouterFunction(GlomoNode *node,
			     Message *msg,
			     NODE_ADDR destAddr,
			     BOOL *packetWasRouted){
	
  GlomoNetworkIp *ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF *IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
  IpHeaderType *ipHeader = (IpHeaderType *) msg->packet;
	
  if(ipHeader->ip_p ==  IPPROTO_IGF){
    // this is the control packet, ignore it
    return;
  }
  if(ipHeader->ip_src == node->nodeAddr)
    {
      *packetWasRouted = TRUE;
    }
  if(node->nodeAddr == destAddr){
    *packetWasRouted = FALSE;
  }else{
    *packetWasRouted = TRUE;
  }
	
  //printf("ROSHAN node %d making routing decision for node %d\n",node->nodeAddr,destAddr);
  IGF_AddToRouteRecord(node,msg);
  //printf("ROSHAN node %d received packet has followed route\n",node->nodeAddr);
  //DisplayRouteOfPacket(node,msg);
  IGF_MakeRoutingDecision(node, msg, destAddr);
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_MakeRoutingDecision(GlomoNode *node, 
			    Message * msg, 
			    NODE_ADDR destAddr) {

  GlomoNetworkIp * ipLayer = (GlomoNetworkIp *)node->networkData.networkVar;
  GlomoRoutingIGF * IGF = (GlomoRoutingIGF *)ipLayer->routingProtocol;
  IpHeaderType * ipHeader = (IpHeaderType *) msg->packet;
  IGF_RT *rt = &(IGF->routeTable);
  NODE_ADDR nextHop;
  char 	TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);

  if(ipHeader->ip_src == node->nodeAddr) {

#if MYDEBUG
    printf("IGF--Node %d sends out a packet to node %d\n",
	   node->nodeAddr,destAddr);
#endif
    
  }

  if(node->nodeAddr == destAddr) {

#if MYDEBUG
    printf("IGF--Node %d receives a packet from %d\n",
	   node->nodeAddr,ipHeader->ip_src);
#endif

    return; 
  } else {

    // Get the next hop and send the packet to the MAC layer
    // through NetworkIpSendPacketToMacLayer
    // ....
      nextHop = IGF_GetNextHop(rt,node,destAddr);
      if(nextHop != 0xffff){
    
          NetworkIpSendPacketToMacLayer(node, msg, DEFAULT_INTERFACE, nextHop);
      }else{
          #ifdef IGF_DEBUG
          printf("[SIM: %15s] IGF--Node %d could not send out a packet to node %d via neighbor %d no closer nbr found \n",
                 TimeStringInSecond,node->nodeAddr,destAddr,nextHop);
#endif
      }
  }
}
NODE_ADDR IGF_GetFinalDestAddr(Message *msg){
IpHeaderType *ipHeader = (IpHeaderType *) msg->packet;
 return ipHeader->ip_dst;

}


//***************************************************************************
//***************************************************************************
//***************************************************************************
NODE_ADDR IGF_GetNextHop(IGF_RT *rt, GlomoNode * node, NODE_ADDR destAddr) {

  IGF_RT_Node *curr_rt_entry;
  NODE_ADDR nextHop = destAddr;
  char TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];

  for(curr_rt_entry=rt->head;curr_rt_entry!=NULL;curr_rt_entry=curr_rt_entry->next){
      if(curr_rt_entry->destAddr == destAddr){
          nextHop = curr_rt_entry->nextHop;
          break;
      }
  }
#ifdef IGF_DEBUG
          printf("[SIM: %15s] IGF--Node %d sends out a packet to node %d via node %d \n",
                 TimeStringInSecond,node->nodeAddr,destAddr,nextHop);
#endif
  return nextHop;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
double IGF_GetDistance(GlomoCoordinates sourceAddr, GlomoCoordinates destAddr){
  double distance_x = ABSOLUTE_VALUE(sourceAddr.x - destAddr.x);
  double distance_y = ABSOLUTE_VALUE(sourceAddr.y - destAddr.y);
  double distance_z = ABSOLUTE_VALUE(sourceAddr.z - destAddr.z);
	 
  return sqrt(distance_x*distance_x + distance_y*distance_y + 
	      distance_z*distance_z);
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_LocServ_Init() {
  IGF_global_ls_table.head = NULL;
  IGF_global_ls_table.size = 0;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
void IGF_LocServ_AddEntry(GlomoNode *node) {
  IGF_LOCATION_SERVICE_ENTRY *currEntry;
  IGF_LOCATION_SERVICE_ENTRY *rearEntry;
  IGF_LOCATION_SERVICE_ENTRY *newEntry = (IGF_LOCATION_SERVICE_ENTRY *) 
      checked_pc_malloc(sizeof(IGF_LOCATION_SERVICE_ENTRY));
  char 	TimeStringInSecond[GLOMO_MAX_STRING_LENGTH];
  GLOMO_PrintClockInSecond(simclock(), TimeStringInSecond);

  newEntry->nodeAddr = node->nodeAddr;
  newEntry->position = node->position;

  // Add the newEntry to the IGF_global_ls_table
  // ...
  //
  newEntry->next = IGF_global_ls_table.head;
  IGF_global_ls_table.head = newEntry;
  IGF_global_ls_table.size++;
  #ifdef IGF_DEBUG
  //printf("[SIM: %15s] %d Added in the LS service\n",TimeStringInSecond,node->nodeAddr);
  #endif
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
GlomoCoordinates IGF_LocServ_Lookup(NODE_ADDR nodeAddr){
  IGF_LOCATION_SERVICE_ENTRY * 	currEntry;
  GlomoCoordinates		result_position;
  BOOL							wasFound;
	
  wasFound = FALSE;

  // Loop over all entries in IGF_LOCATION_SERVICE and return the location of node
  // .....
  // .....
  // TODO
  for(currEntry = IGF_global_ls_table.head;currEntry!=NULL;currEntry=currEntry->next){
      if(currEntry->nodeAddr==nodeAddr){
          wasFound = TRUE;
          result_position = currEntry->position;
          break;
      }
  }

  if(!wasFound){
    printf("Fail to find the location of node %d\n",nodeAddr);
    abort();
  }
  return result_position;
}

void IGF_updateLocation(NODE_ADDR nodeAddr, GlomoCoordinates position){
    BOOL wasFound = FALSE;
    IGF_LOCATION_SERVICE_ENTRY * currEntry;
    for(currEntry = IGF_global_ls_table.head;currEntry!=NULL;currEntry=currEntry->next){
        if(currEntry->nodeAddr==nodeAddr){
            wasFound = TRUE;
            currEntry->position=position;
            break;
        }
    }

}

int IGF_GetRouteRecord(Message * msg,NODE_ADDR* nodesarray){
 IpOptionsHeaderType* ipOptions = 
        FindAnIpOptionField((IpHeaderType*)msg->packet,IPOPT_RR);
 int count = 0;
 //char temp = ipOptions->ptr;
 char temp = IPOPT_MINOFF;
    while (temp < ipOptions->len) {
         
        // Extract Next Address 
        // The definition of "ptr" seems to number 1 as the 
        // first byte of the the options field.
        
        char* routeRawAddressBytes = (char*)ipOptions + temp;
        
        NODE_ADDR nextHop = 
            ConvertRawAddressBytesToNodeAddress(routeRawAddressBytes);
        
        // Record Route (Replace next address with this node's address).
        
        temp += sizeof(NODE_ADDR);
        
        *nodesarray = nextHop;
        nodesarray += 1;
        count++;
    } 
    return count;

}
